name: Build Application

on:
  push:
    branches: [ main, master ]
    tags:
      - 'v*'
  pull_request:
    branches: [ main, master ]
  release:
    types: [ created ]
  workflow_dispatch:

jobs:
  build-windows:
    name: Build Windows .exe
    runs-on: windows-latest
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install flet
        Write-Host "Verifying Flet installation..."
        Write-Host "Checking if flet command is available..."
        $fletPath = Get-Command flet -ErrorAction SilentlyContinue
        if ($fletPath) {
          Write-Host "flet found at: $($fletPath.Source)"
          Write-Host "Flet version:"
          flet --version
        } else {
          Write-Host "flet not in PATH, adding Python Scripts to PATH..."
          $pythonPath = python -c "import sys; print(sys.executable)"
          $scriptsPath = Join-Path (Split-Path $pythonPath -Parent) "Scripts"
          $env:PATH = "$scriptsPath;$env:PATH"
          Write-Host "Updated PATH, checking again..."
          $fletPath = Get-Command flet -ErrorAction SilentlyContinue
          if ($fletPath) {
            Write-Host "flet found at: $($fletPath.Source)"
            Write-Host "Flet version:"
            flet --version
          } else {
            Write-Host "WARNING: flet command still not found"
            Write-Host "Trying to verify via import..."
            python -c "import flet; print('Flet module imported successfully')"
          }
        }
    
    - name: Build Windows executable
      run: |
        Write-Host "=== Starting Flet build ==="
        Write-Host "Python version:"
        python --version
        Write-Host "Flet version:"
        # Try flet command, fallback to python -m flet.cli if not in PATH
        $fletCmd = Get-Command flet -ErrorAction SilentlyContinue
        if ($fletCmd) {
          flet --version
        } else {
          Write-Host "flet not in PATH, trying python -m flet.cli..."
          python -m flet.cli --version 2>&1 || python -c "import flet; print(f'Flet {flet.__version__}')"
        }
        Write-Host "Current directory:"
        Get-Location
        Write-Host "Directory contents:"
        Get-ChildItem | Select-Object Name, Length
        Write-Host "`n=== Environment variables ==="
        Write-Host "PYTHONIOENCODING: $env:PYTHONIOENCODING"
        Write-Host "FLET_LOG_LEVEL: $env:FLET_LOG_LEVEL"
        Write-Host "`n=== Running flet build windows with verbose logging ==="
        Write-Host "Python version:"
        python --version
        Write-Host "Flet version:"
        # Try flet command, fallback to python -m flet.cli if not in PATH
        $fletCmd = Get-Command flet -ErrorAction SilentlyContinue
        if ($fletCmd) {
          flet --version
          $fletBuildCmd = "flet"
        } else {
          Write-Host "flet not in PATH, trying python -m flet.cli..."
          python -m flet.cli --version 2>&1 || python -c "import flet; print(f'Flet {flet.__version__}')"
          $fletBuildCmd = "python -m flet.cli"
        }
        
        # Set verbose environment variables
        $env:FLET_LOG_LEVEL = "DEBUG"
        $env:VERBOSE = "1"
        $env:FLUTTER_VERBOSE = "1"
        
        # Run build and capture both stdout and stderr
        $buildOutput = & $fletBuildCmd build windows 2>&1 | Tee-Object -FilePath build_log.txt
        
        # Also try to capture Flutter build logs
        if (Test-Path "build\flutter\windows\build\runner\Release\build.log") {
          Write-Host "`n=== Flutter build log ==="
          Get-Content "build\flutter\windows\build\runner\Release\build.log" -Tail 100 -ErrorAction SilentlyContinue
        }
        
        # Check for CMake logs
        $cmakeLogs = Get-ChildItem -Path build -Recurse -Filter "CMake*.log" -ErrorAction SilentlyContinue | Select-Object -First 5
        if ($cmakeLogs) {
          Write-Host "`n=== CMake logs found ==="
          foreach ($log in $cmakeLogs) {
            Write-Host "`n--- $($log.FullName) ---"
            Get-Content $log.FullName -Tail 50 -ErrorAction SilentlyContinue
          }
        }
        
        Write-Host "`n=== Build completed ==="
        Write-Host "Exit code: $LASTEXITCODE"
        if (Test-Path build_log.txt) {
          Write-Host "Build log saved to build_log.txt ($((Get-Item build_log.txt).Length) bytes)"
          Write-Host "`n=== Last 100 lines of build log ==="
          Get-Content build_log.txt -Tail 100
        }
        
        # Check for errors in log
        if (Test-Path build_log.txt) {
          $errors = Select-String -Path build_log.txt -Pattern "error|Error|ERROR|failed|Failed|FAILED|exception|Exception" -CaseSensitive:$false
          if ($errors) {
            Write-Host "`n=== Potential errors/warnings in log ==="
            $errors | Select-Object -First 20 | ForEach-Object { Write-Host $_.Line }
          }
        }
      env:
        PYTHONIOENCODING: utf-8
        FLET_LOG_LEVEL: DEBUG
        VERBOSE: 1
        FLUTTER_VERBOSE: 1
    
    - name: Collect all build logs
      shell: pwsh
      if: always()
      run: |
        Write-Host "=== Collecting all build logs ==="
        $logsDir = "build_logs"
        New-Item -ItemType Directory -Force -Path $logsDir | Out-Null
        
        # Copy main build log
        if (Test-Path build_log.txt) {
          Copy-Item build_log.txt -Destination "$logsDir\flet_build.log" -Force
          Write-Host "Copied: flet_build.log"
        }
        
        # Find and copy all log files
        $allLogs = Get-ChildItem -Path build -Recurse -Include "*.log","*.txt" -ErrorAction SilentlyContinue | Where-Object {
          $_.Name -like "*log*" -or $_.Name -like "*error*" -or $_.Name -like "*build*"
        }
        
        if ($allLogs) {
          Write-Host "Found $($allLogs.Count) log file(s):"
          foreach ($log in $allLogs) {
            $relativePath = $log.FullName.Replace((Get-Location).Path + "\", "").Replace("\", "_")
            $destPath = Join-Path $logsDir $relativePath
            $destDir = Split-Path $destPath -Parent
            if (-not (Test-Path $destDir)) {
              New-Item -ItemType Directory -Force -Path $destDir | Out-Null
            }
            Copy-Item $log.FullName -Destination $destPath -Force -ErrorAction SilentlyContinue
            Write-Host "  Copied: $relativePath"
          }
        }
        
        # Copy CMake cache and config
        $cmakeFiles = Get-ChildItem -Path build -Recurse -Include "CMakeCache.txt","CMakeFiles" -ErrorAction SilentlyContinue
        if ($cmakeFiles) {
          Write-Host "Found CMake files:"
          foreach ($file in $cmakeFiles) {
            if ($file.PSIsContainer) {
              $relativePath = $file.FullName.Replace((Get-Location).Path + "\", "").Replace("\", "_")
              Copy-Item $file.FullName -Destination "$logsDir\$relativePath" -Recurse -Force -ErrorAction SilentlyContinue
            } else {
              $relativePath = $file.FullName.Replace((Get-Location).Path + "\", "").Replace("\", "_")
              Copy-Item $file.FullName -Destination "$logsDir\$relativePath" -Force -ErrorAction SilentlyContinue
            }
            Write-Host "  Copied: $relativePath"
          }
        }
        
        Write-Host "`n=== Logs summary ==="
        Get-ChildItem -Path $logsDir -Recurse -File | ForEach-Object {
          Write-Host "$($_.Name): $([math]::Round($_.Length/1KB, 2)) KB"
        }
    
    - name: Upload test logs
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: test-logs
        path: |
          test_output.txt
          test_error.txt
        if-no-files-found: ignore
        retention-days: 7
    
    - name: Upload build logs
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: build-logs
        path: |
          build_log.txt
          build_logs/**
          build/**/*.log
          build/**/CMakeCache.txt
        retention-days: 7
    
    - name: Find executable and prepare package
      shell: pwsh
      run: |
        Write-Host "=== Searching for .exe files ==="
        Write-Host "Build directory structure:"
        if (Test-Path build) {
          Get-ChildItem -Path build -Recurse -Directory | Select-Object -First 20 FullName | ForEach-Object { Write-Host "  $($_.FullName)" }
        } else {
          Write-Host "ERROR: Build directory does not exist!"
          exit 1
        }
        $allExes = Get-ChildItem -Path build -Recurse -Filter "*.exe" -ErrorAction SilentlyContinue
        if ($allExes) {
          Write-Host "Found $($allExes.Count) executable(s):"
          $allExes | ForEach-Object { 
            Write-Host "  $($_.FullName) (Size: $([math]::Round($_.Length/1MB, 2)) MB)"
          }
          
          $releaseExe = $allExes | Where-Object { $_.DirectoryName -like "*Release*" } | Select-Object -First 1
          if (-not $releaseExe) {
            $releaseExe = $allExes | Where-Object { $_.DirectoryName -like "*runner*" } | Select-Object -First 1
          }
          if (-not $releaseExe) {
            $releaseExe = $allExes | Select-Object -First 1
          }
          
          if ($releaseExe) {
            Write-Host "`nUsing executable: $($releaseExe.FullName)"
            $exeDir = $releaseExe.DirectoryName
            $packageDir = "package"
            New-Item -ItemType Directory -Force -Path $packageDir | Out-Null
            
            Write-Host "Copying executable..."
            Copy-Item $releaseExe.FullName -Destination "$packageDir\$($releaseExe.Name)" -Force
            
            Write-Host "Copying all DLL files from $exeDir..."
            $dlls = Get-ChildItem -Path $exeDir -Filter "*.dll" -ErrorAction SilentlyContinue
            if ($dlls) {
              Write-Host "Found $($dlls.Count) DLL file(s):"
              $dlls | ForEach-Object {
                Copy-Item $_.FullName -Destination "$packageDir\$($_.Name)" -Force
                Write-Host "  Copied: $($_.Name)"
              }
            } else {
              Write-Host "WARNING: No DLL files found in $exeDir"
            }
            
            Write-Host "Searching for DLL files in parent directories..."
            $parentDir = Split-Path $exeDir -Parent
            $allDlls = Get-ChildItem -Path $parentDir -Recurse -Filter "*.dll" -ErrorAction SilentlyContinue | Where-Object { $_.DirectoryName -ne $exeDir }
            if ($allDlls) {
              Write-Host "Found $($allDlls.Count) additional DLL file(s):"
              $allDlls | ForEach-Object {
                $destPath = "$packageDir\$($_.Name)"
                if (-not (Test-Path $destPath)) {
                  Copy-Item $_.FullName -Destination $destPath -Force
                  Write-Host "  Copied: $($_.Name) from $($_.DirectoryName)"
                }
              }
            }
            
            Write-Host "Copying data directory if exists..."
            $dataDir = Join-Path $exeDir "data"
            if (Test-Path $dataDir) {
              Copy-Item -Path $dataDir -Destination "$packageDir\data" -Recurse -Force
              Write-Host "  Copied data directory"
            }
            
            # Check app.zip contents - Flet packages Python app in app.zip
            Write-Host "`n=== Checking app.zip contents ==="
            $appZipPath = Join-Path $dataDir "flutter_assets" "app" "app.zip"
            if (Test-Path $appZipPath) {
              Write-Host "Found app.zip: $appZipPath"
              $zipSize = (Get-Item $appZipPath).Length
              Write-Host "Size: $([math]::Round($zipSize/1MB, 2)) MB"
              
              # Try to extract and check contents
              try {
                Add-Type -AssemblyName System.IO.Compression.FileSystem
                $zip = [System.IO.Compression.ZipFile]::OpenRead($appZipPath)
                $entries = $zip.Entries | Select-Object -First 50
                Write-Host "`nFirst 50 entries in app.zip:"
                foreach ($entry in $entries) {
                  Write-Host "  $($entry.FullName)"
                }
                Write-Host "`nTotal entries: $($zip.Entries.Count)"
                
                # Check for encodings in zip
                $encodingsInZip = $zip.Entries | Where-Object { $_.FullName -like "*encodings*" } | Select-Object -First 10
                if ($encodingsInZip) {
                  Write-Host "`nFound encodings in app.zip:"
                  $encodingsInZip | ForEach-Object { Write-Host "  $($_.FullName)" }
                } else {
                  Write-Host "`n⚠ WARNING: encodings module NOT found in app.zip!"
                }
                
                # Check for Lib directory in zip
                $libInZip = $zip.Entries | Where-Object { $_.FullName -like "Lib/*" } | Select-Object -First 20
                if ($libInZip) {
                  Write-Host "`nFound Lib directory entries in app.zip:"
                  $libInZip | ForEach-Object { Write-Host "  $($_.FullName)" }
                } else {
                  Write-Host "`n⚠ WARNING: Lib directory NOT found in app.zip!"
                }
                
                $zip.Dispose()
              } catch {
                Write-Host "Could not read app.zip: $_"
              }
            } else {
              Write-Host "⚠ WARNING: app.zip not found at expected location: $appZipPath"
            }
            
            # Search for Python runtime files in build directory
            Write-Host "`n=== Searching for Python runtime files in build directory ==="
            $buildRoot = Split-Path $exeDir -Parent -ErrorAction SilentlyContinue
            $buildFlutter = Split-Path $buildRoot -Parent -ErrorAction SilentlyContinue
            
            # Search recursively for Python Lib directory
            $pythonLibDirs = Get-ChildItem -Path $buildRoot -Recurse -Directory -Filter "Lib" -ErrorAction SilentlyContinue | Where-Object {
              $_.Parent.Name -like "*python*" -or 
              (Test-Path (Join-Path $_.FullName "encodings")) -or
              (Get-ChildItem -Path $_.FullName -Filter "encodings" -Directory -ErrorAction SilentlyContinue)
            } | Select-Object -First 5
            
            $libSourceDir = $null
            if ($pythonLibDirs) {
              Write-Host "Found potential Python Lib directories:"
              foreach ($libDir in $pythonLibDirs) {
                Write-Host "  $($libDir.FullName)"
                $encodingsCheck = Join-Path $libDir.FullName "encodings"
                if (Test-Path $encodingsCheck) {
                  Write-Host "    ✓ Contains encodings module"
                  $libSourceDir = $libDir
                  
                  # Count files before copying
                  $fileCount = (Get-ChildItem -Path $libDir.FullName -Recurse -File -ErrorAction SilentlyContinue | Measure-Object).Count
                  $dirCount = (Get-ChildItem -Path $libDir.FullName -Recurse -Directory -ErrorAction SilentlyContinue | Measure-Object).Count
                  Write-Host "    Files: $fileCount, Directories: $dirCount"
                  
                  $destLib = Join-Path $packageDir "Lib"
                  if (-not (Test-Path $destLib)) {
                    Write-Host "    Copying Lib directory (this may take a while)..."
                    Copy-Item -Path $libDir.FullName -Destination $destLib -Recurse -Force
                    
                    # Verify copy and fix missing __init__.py files
                    if (Test-Path $destLib) {
                      $copiedFiles = (Get-ChildItem -Path $destLib -Recurse -File -ErrorAction SilentlyContinue | Measure-Object).Count
                      $copiedDirs = (Get-ChildItem -Path $destLib -Recurse -Directory -ErrorAction SilentlyContinue | Measure-Object).Count
                      Write-Host "    ✓ Copied to: $destLib"
                      Write-Host "    Copied files: $copiedFiles, directories: $copiedDirs"
                      
                      # Fix all missing __init__.py files
                      Write-Host "    Checking and fixing __init__.py files..."
                      $allDirs = Get-ChildItem -Path $destLib -Recurse -Directory -ErrorAction SilentlyContinue
                      $fixedCount = 0
                      foreach ($dir in $allDirs) {
                        $initFile = Join-Path $dir.FullName "__init__.py"
                        if (-not (Test-Path $initFile)) {
                          $relativePath = $dir.FullName.Replace($destLib, "").TrimStart("\")
                          $sourceDir = Join-Path $libDir.FullName $relativePath
                          $sourceInit = Join-Path $sourceDir "__init__.py"
                          if (Test-Path $sourceInit) {
                            Copy-Item $sourceInit -Destination $initFile -Force
                            $fixedCount++
                          }
                        }
                      }
                      if ($fixedCount -gt 0) {
                        Write-Host "    ✓ Fixed $fixedCount missing __init__.py files"
                      }
                      
                      # Check encodings specifically
                      $destEncodings = Join-Path $destLib "encodings"
                      if (Test-Path $destEncodings) {
                        $encodingsFiles = (Get-ChildItem -Path $destEncodings -Recurse -File -ErrorAction SilentlyContinue | Measure-Object).Count
                        $encodingsInit = Join-Path $destEncodings "__init__.py"
                        if (Test-Path $encodingsInit) {
                          Write-Host "    ✓ encodings module copied: $encodingsFiles files (including __init__.py)"
                        } else {
                          Write-Host "    ⚠ encodings __init__.py still missing after fix attempt"
                        }
                      } else {
                        Write-Host "    ✗ encodings module NOT copied!"
                      }
                    } else {
                      Write-Host "    ✗ Copy failed - destination does not exist"
                    }
                  } else {
                    Write-Host "    Lib already exists in package"
                    # Still check and fix __init__.py files
                    $destEncodings = Join-Path $destLib "encodings"
                    $encodingsInit = Join-Path $destEncodings "__init__.py"
                    if (-not (Test-Path $encodingsInit)) {
                      $sourceInit = Join-Path $libDir.FullName "encodings\__init__.py"
                      if (Test-Path $sourceInit) {
                        Write-Host "    Fixing missing encodings __init__.py..."
                        Copy-Item $sourceInit -Destination $encodingsInit -Force
                      }
                    }
                  }
                  break
                }
              }
            } else {
              Write-Host "⚠ No Python Lib directories found in build"
            }
            
            # Search for python312.zip (or python*.zip) in the same directory as Lib
            Write-Host "`n=== Searching for Python standard library zip file ==="
            if ($libSourceDir) {
              $libParentDir = $libSourceDir.Parent
              $pythonZipFiles = Get-ChildItem -Path $libParentDir -Filter "python*.zip" -ErrorAction SilentlyContinue
              if ($pythonZipFiles) {
                foreach ($zipFile in $pythonZipFiles) {
                  Write-Host "Found: $($zipFile.FullName)"
                  $destZip = Join-Path $packageDir $zipFile.Name
                  Copy-Item $zipFile.FullName -Destination $destZip -Force
                  Write-Host "  ✓ Copied to: $destZip"
                }
              } else {
                Write-Host "⚠ No python*.zip file found in $libParentDir"
                # Try searching in build directory
                $allPythonZips = Get-ChildItem -Path $buildRoot -Recurse -Filter "python*.zip" -ErrorAction SilentlyContinue | Select-Object -First 3
                if ($allPythonZips) {
                  Write-Host "Found python*.zip files elsewhere:"
                  foreach ($zipFile in $allPythonZips) {
                    Write-Host "  $($zipFile.FullName)"
                    $destZip = Join-Path $packageDir $zipFile.Name
                    if (-not (Test-Path $destZip)) {
                      Copy-Item $zipFile.FullName -Destination $destZip -Force
                      Write-Host "    ✓ Copied to: $destZip"
                    }
                  }
                }
              }
            } else {
              Write-Host "⚠ Cannot search for python*.zip - Lib directory not found"
            }
            
            # Check for encodings module after copying
            Write-Host "`n=== Final check for encodings module ==="
            $encodingsDir = Join-Path $packageDir "Lib\encodings"
            $encodingsInit = Join-Path $encodingsDir "__init__.py"
            $pythonZip = Get-ChildItem -Path $packageDir -Filter "python*.zip" -ErrorAction SilentlyContinue | Select-Object -First 1
            
            $foundEncodings = $false
            if (Test-Path $encodingsDir) {
              Write-Host "✓ Found: $encodingsDir"
              $foundEncodings = $true
              if (Test-Path $encodingsInit) {
                Write-Host "✓ Found: $encodingsInit"
              } else {
                Write-Host "✗ MISSING: $encodingsInit"
                # Try to fix one more time if we have source
                if ($libSourceDir) {
                  $sourceInit = Join-Path $libSourceDir.FullName "encodings\__init__.py"
                  if (Test-Path $sourceInit) {
                    Write-Host "  Attempting final fix..."
                    Copy-Item $sourceInit -Destination $encodingsInit -Force
                    if (Test-Path $encodingsInit) {
                      Write-Host "  ✓ Fixed: $encodingsInit"
                    } else {
                      Write-Host "  ✗ Fix failed"
                    }
                  }
                }
              }
            } else {
              Write-Host "✗ MISSING: $encodingsDir"
            }
            
            if ($pythonZip) {
              Write-Host "✓ Found: $($pythonZip.FullName)"
            } else {
              Write-Host "✗ MISSING: python*.zip"
            }
            
            # Final verification - check all critical __init__.py files
            if ($foundEncodings -and (Test-Path (Join-Path $packageDir "Lib"))) {
              Write-Host "`n=== Verifying critical Python modules ==="
              $criticalModules = @("encodings", "collections", "io", "os", "sys")
              foreach ($module in $criticalModules) {
                $moduleDir = Join-Path (Join-Path $packageDir "Lib") $module
                $moduleInit = Join-Path $moduleDir "__init__.py"
                if (Test-Path $moduleDir) {
                  if (Test-Path $moduleInit) {
                    Write-Host "  ✓ $module"
                  } else {
                    Write-Host "  ✗ $module (missing __init__.py)"
                    if ($libSourceDir) {
                      $sourceInit = Join-Path $libSourceDir.FullName "$module\__init__.py"
                      if (Test-Path $sourceInit) {
                        Copy-Item $sourceInit -Destination $moduleInit -Force
                        if (Test-Path $moduleInit) {
                          Write-Host "    ✓ Fixed"
                        }
                      }
                    }
                  }
                } else {
                  Write-Host "  ✗ $module (directory missing)"
                }
              }
            }
            
            if (-not $foundEncodings) {
              Write-Host "`n❌ ERROR: encodings module not found! Python standard library is missing."
              Write-Host "The application will fail at startup with: ModuleNotFoundError: No module named 'encodings'"
              Write-Host "`nThis is a known issue with Flet build - Python standard library may not be included."
              Write-Host "Possible solutions:"
              Write-Host "  1. Check if Flet includes Python standard library in app.zip"
              Write-Host "  2. Manually add Python Lib directory to the package"
              Write-Host "  3. Report this as a bug to Flet project"
            }
            
            Write-Host "`nPackage prepared in: $packageDir"
            Write-Host "`n=== Package contents summary ==="
            Get-ChildItem -Path $packageDir | ForEach-Object { 
              if ($_.PSIsContainer) {
                $itemCount = (Get-ChildItem -Path $_.FullName -Recurse -ErrorAction SilentlyContinue | Measure-Object).Count
                $size = (Get-ChildItem -Path $_.FullName -Recurse -File -ErrorAction SilentlyContinue | Measure-Object -Property Length -Sum).Sum
                Write-Host "  $($_.Name)/ (Items: $itemCount, Size: $([math]::Round($size/1MB, 2)) MB)"
              } else {
                Write-Host "  $($_.Name) ($([math]::Round($_.Length/1KB, 2)) KB)"
              }
            }
            
            Write-Host "`n=== Verifying executable ==="
            $exePath = Join-Path $packageDir $releaseExe.Name
            if (Test-Path $exePath) {
              Write-Host "Executable found: $exePath"
              $fileInfo = Get-Item $exePath
              Write-Host "Size: $([math]::Round($fileInfo.Length/1MB, 2)) MB"
              Write-Host "Last modified: $($fileInfo.LastWriteTime)"
              
              # Try to get file version info
              try {
                $versionInfo = [System.Diagnostics.FileVersionInfo]::GetVersionInfo($exePath)
                Write-Host "File version: $($versionInfo.FileVersion)"
                Write-Host "Product version: $($versionInfo.ProductVersion)"
              } catch {
                Write-Host "Could not read version info: $_"
              }
            } else {
              Write-Host "ERROR: Executable not found at $exePath"
              exit 1
            }
          } else {
            Write-Host "ERROR: Could not find executable"
            Write-Host "All found executables:"
            $allExes | ForEach-Object { Write-Host "  $($_.FullName)" }
            exit 1
          }
        } else {
          Write-Host "ERROR: No .exe files found in build directory"
          Write-Host "`nBuild directory structure:"
          if (Test-Path build) {
            Get-ChildItem -Path build -Recurse -Directory | Select-Object -First 30 | ForEach-Object { Write-Host "  $($_.FullName)" }
            Write-Host "`nAll files in build directory:"
            Get-ChildItem -Path build -Recurse -File | Select-Object -First 50 FullName | ForEach-Object { Write-Host "  $($_.FullName)" }
          } else {
            Write-Host "Build directory does not exist!"
          }
            exit 1
        }
    
    - name: Test executable (basic check)
      shell: pwsh
      run: |
        $exePath = Get-ChildItem -Path package -Filter "*.exe" -ErrorAction SilentlyContinue | Select-Object -First 1
        if ($exePath) {
          Write-Host "=== Testing executable: $($exePath.FullName) ==="
          Write-Host "File exists: $(Test-Path $exePath.FullName)"
          Write-Host "File size: $([math]::Round($exePath.Length/1MB, 2)) MB"
          
          # Check if it's a valid PE executable
          $bytes = [System.IO.File]::ReadAllBytes($exePath.FullName)
          if ($bytes.Length -ge 2) {
            $peSignature = [System.Text.Encoding]::ASCII.GetString($bytes[0..1])
            if ($peSignature -eq "MZ") {
              Write-Host "✓ Valid PE executable (MZ signature found)"
            } else {
              Write-Host "⚠ Warning: File does not have MZ signature"
            }
          }
          
          # Try to get dependencies using dumpbin if available
          $dumpbinPath = "${env:ProgramFiles}\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\*\bin\Hostx64\x64\dumpbin.exe"
          $dumpbin = Get-ChildItem -Path $dumpbinPath -ErrorAction SilentlyContinue | Select-Object -First 1
          if ($dumpbin) {
            Write-Host "`n=== Checking DLL dependencies ==="
            $dependencies = & $dumpbin.FullName /dependents $exePath.FullName 2>&1
            $dllList = $dependencies | Select-String -Pattern "\.dll" | ForEach-Object { $_.Line.Trim() }
            if ($dllList) {
              Write-Host "Required DLLs:"
              $dllList | ForEach-Object { Write-Host "  $_" }
              
              # Check which DLLs are present in package
              Write-Host "`nDLLs in package:"
              $packageDlls = Get-ChildItem -Path package -Filter "*.dll" -ErrorAction SilentlyContinue
              $packageDllNames = $packageDlls | ForEach-Object { $_.Name }
              foreach ($dll in $dllList) {
                if ($packageDllNames -contains $dll) {
                  Write-Host "  ✓ $dll (found)"
                } else {
                  Write-Host "  ✗ $dll (MISSING)"
                }
              }
            }
          }
          
          Write-Host "`n=== Attempting test run (will timeout after 5 seconds) ==="
          try {
            $process = Start-Process -FilePath $exePath.FullName -WorkingDirectory $exePath.DirectoryName -PassThru -NoNewWindow -RedirectStandardOutput "test_output.txt" -RedirectStandardError "test_error.txt"
            Start-Sleep -Seconds 5
            if (-not $process.HasExited) {
              Write-Host "Process is still running (good sign)"
              Stop-Process -Id $process.Id -Force -ErrorAction SilentlyContinue
            } else {
              Write-Host "Process exited with code: $($process.ExitCode)"
              if (Test-Path "test_output.txt") {
                Write-Host "`n=== Standard output ==="
                Get-Content "test_output.txt" -ErrorAction SilentlyContinue
              }
              if (Test-Path "test_error.txt") {
                Write-Host "`n=== Standard error ==="
                Get-Content "test_error.txt" -ErrorAction SilentlyContinue
              }
            }
          } catch {
            Write-Host "Error running executable: $_"
            if (Test-Path "test_error.txt") {
              Write-Host "`n=== Error output ==="
              Get-Content "test_error.txt" -ErrorAction SilentlyContinue
            }
          }
          
          Write-Host "Executable verification complete"
        } else {
          Write-Host "ERROR: No executable found in package directory"
          exit 1
        }
      continue-on-error: true
    
    - name: Upload Windows artifact
      uses: actions/upload-artifact@v4
      with:
        name: windows-exe
        path: |
          package/*.exe
          package/*.dll
          package/data/**
          package/Lib/**
        if-no-files-found: error
        retention-days: 30

  build-linux-rpm:
    name: Build Linux .rpm (Fedora)
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Build RPM in Fedora container
      run: |
        echo "=== Starting Linux RPM build ==="
        echo "Workspace: ${{ github.workspace }}"
        docker run --rm \
          -v ${{ github.workspace }}:/workspace \
          -w /workspace \
          fedora:latest bash -c "
          set -x
          echo '=== Installing dependencies ==='
          dnf install -y rpm-build python3-devel python3-pip git cmake ninja-build clang gtk3-devel 2>&1 | tee /tmp/dnf_install.log
          echo '=== Python version ==='
          python3 --version
          echo '=== Installing Python packages ==='
          python3 -m pip install --upgrade pip 2>&1 | tee /tmp/pip_upgrade.log
          pip3 install flet 2>&1 | tee /tmp/pip_install.log
          echo '=== Flet version ==='
          flet --version || python3 -m flet.cli --version || echo 'Flet not found'
          echo '=== Current directory structure ==='
          ls -la /workspace/ || true
          echo '=== Building with Flet ==='
          if ! flet build linux 2>&1 | tee /tmp/flet_build.log; then
            echo 'Flet build failed, trying with python -m flet.cli...'
            python3 -m flet.cli build linux 2>&1 | tee -a /tmp/flet_build.log || {
              echo 'ERROR: Flet build failed'
              cat /tmp/flet_build.log
              exit 1
            }
          fi
          echo '=== Checking build output ==='
          BUNDLE_DIR=''
          if [ -d /workspace/build/flutter/linux/build/bundle ]; then
            BUNDLE_DIR='/workspace/build/flutter/linux/build/bundle'
            echo 'Build bundle found at: '\$BUNDLE_DIR
            ls -lah \$BUNDLE_DIR/ || true
          elif [ -d /workspace/build/flutter/linux/bundle ]; then
            BUNDLE_DIR='/workspace/build/flutter/linux/bundle'
            echo 'Build bundle found at: '\$BUNDLE_DIR
            ls -lah \$BUNDLE_DIR/ || true
          else
            echo 'ERROR: Bundle directory not found'
            echo 'Searching for bundle:'
            find /workspace/build -type d -name bundle 2>/dev/null | head -5
            exit 1
          fi
          
          BINARY_NAME='csv_json_generator'
          if [ ! -f \"\$BUNDLE_DIR/\$BINARY_NAME\" ]; then
            echo 'WARNING: Binary not found at '\$BUNDLE_DIR/\$BINARY_NAME
            echo 'Looking for executables:'
            find \$BUNDLE_DIR -type f -executable 2>/dev/null | head -10
            BINARY_NAME=\$(find \$BUNDLE_DIR -type f -executable 2>/dev/null | head -1 | xargs basename)
            echo 'Using binary: '\$BINARY_NAME
          fi
          
          echo '=== Creating RPM package ==='
          mkdir -p /tmp/rpmbuild/{BUILD,RPMS,SOURCES,SPECS,SRPMS}
          APP_NAME='csv-json-generator'
          APP_VERSION='0.1.0'
          
          echo '=== Creating RPM spec file ==='
          cat > /tmp/rpmbuild/SPECS/\${APP_NAME}.spec << 'SPECEOF'
          %define app_name csv-json-generator
          %define app_version 0.1.0
          %define binary_name BINARY_NAME_PLACEHOLDER
          
          Name:           %{app_name}
          Version:        %{app_version}
          Release:        1%{?dist}
          Summary:        CSV to JSON Generator
          License:        MIT
          URL:            https://github.com/user/csvjsonapp
          
          %description
          Конвертер CSV в JSON с поддержкой фотографий
          
          %prep
          # Nothing to do
          
          %build
          # Nothing to do
          
          %install
          mkdir -p %{buildroot}/usr/bin
          mkdir -p %{buildroot}/usr/share/%{app_name}
          cp -r BUNDLE_DIR_PLACEHOLDER/* %{buildroot}/usr/share/%{app_name}/
          ln -sf /usr/share/%{app_name}/%{binary_name} %{buildroot}/usr/bin/%{binary_name}
          
          %files
          /usr/bin/%{binary_name}
          /usr/share/%{app_name}
          
          %changelog
          * $(date '+%a %b %d %Y') Build <build@example.com> - %{app_version}-1
          - Initial package
          SPECEOF
          sed -i \"s/BINARY_NAME_PLACEHOLDER/\$BINARY_NAME/g\" /tmp/rpmbuild/SPECS/\${APP_NAME}.spec
          sed -i \"s|BUNDLE_DIR_PLACEHOLDER|\$BUNDLE_DIR|g\" /tmp/rpmbuild/SPECS/\${APP_NAME}.spec
          
          echo '=== Building RPM ==='
          rpmbuild --define '_topdir /tmp/rpmbuild' -bb /tmp/rpmbuild/SPECS/\${APP_NAME}.spec 2>&1 | tee /tmp/rpmbuild.log
          echo '=== Checking for RPM files ==='
          find /tmp/rpmbuild/RPMS -name '*.rpm' -type f
          echo '=== Copying RPM to workspace ==='
          mkdir -p /workspace/dist
          cp /tmp/rpmbuild/RPMS/*/*.rpm /workspace/dist/ 2>&1 || true
          echo '=== Build logs ==='
          echo '--- DNF Install Log ---'
          cat /tmp/dnf_install.log || true
          echo '--- Flet Build Log ---'
          cat /tmp/flet_build.log || true
          echo '--- RPM Build Log ---'
          cat /tmp/rpmbuild.log || true
          echo '=== Final workspace structure ==='
          ls -la /workspace/ | head -30
          if [ -d /workspace/dist ]; then
            echo '=== Dist directory contents ==='
            ls -lah /workspace/dist/ || true
          fi
          "
    
    - name: Check RPM build result
      run: |
        echo "=== Checking RPM build results ==="
        echo "Current directory: $(pwd)"
        echo "Workspace contents:"
        ls -la | head -20
        echo ""
        echo "Searching for RPM files in workspace:"
        find . -name "*.rpm" -type f 2>/dev/null | head -20 || echo "No RPM files found"
        echo ""
        if [ -d dist ]; then
          echo "✓ dist directory exists"
          ls -lah dist/
          RPM_COUNT=$(find dist -name "*.rpm" -type f 2>/dev/null | wc -l)
          echo "Found $RPM_COUNT RPM file(s)"
          if [ $RPM_COUNT -eq 0 ]; then
            echo "WARNING: No RPM files found in dist/"
            echo "Contents of dist/:"
            ls -la dist/ || true
            echo "Searching in other locations:"
            find . -type d -name "*dist*" 2>/dev/null | head -10
          else
            echo "✓ RPM files found:"
            find dist -name "*.rpm" -type f -exec ls -lh {} \;
          fi
        else
          echo "WARNING: dist directory does not exist"
          echo "Checking for alternative locations:"
          find . -type d -name "*dist*" -o -name "*build*" 2>/dev/null | head -20
          echo ""
          echo "All directories in workspace:"
          find . -type d -maxdepth 2 2>/dev/null | head -30
          echo ""
          echo "NOTE: This is not a fatal error - RPM build may have failed or used different output location"
        fi
    
    - name: Upload Linux RPM artifact
      uses: actions/upload-artifact@v4
      with:
        name: linux-rpm
        path: dist/*.rpm
        if-no-files-found: warn
        retention-days: 30

  create-release:
    name: Create Release
    needs: [build-windows, build-linux-rpm]
    runs-on: ubuntu-latest
    if: |
      (github.event_name == 'release' && github.event.action == 'created') ||
      (github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v'))
    
    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0
    
    - name: Get version from tag
      id: get_version
      run: |
        if [ "${{ github.event_name }}" == "push" ]; then
          VERSION=${GITHUB_REF#refs/tags/}
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "tag=$VERSION" >> $GITHUB_OUTPUT
        else
          VERSION=${{ github.event.release.tag_name }}
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "tag=$VERSION" >> $GITHUB_OUTPUT
        fi
        echo "Version: $VERSION"
    
    - name: Download Windows artifacts
      uses: actions/download-artifact@v4
      with:
        name: windows-exe
        path: release/windows
    
    - name: Download Linux RPM artifacts
      uses: actions/download-artifact@v4
      continue-on-error: true
      with:
        name: linux-rpm
        path: release/linux
    
    - name: Create Release
      uses: softprops/action-gh-release@v1
      with:
        tag_name: ${{ steps.get_version.outputs.tag }}
        name: Release ${{ steps.get_version.outputs.version }}
        files: |
          release/windows/**
          release/linux/**
        draft: false
        prerelease: false
        generate_release_notes: true
        body: |
          ## Что нового
          
          Автоматически собранные артефакты для версии ${{ steps.get_version.outputs.version }}
          
          ### Скачать
          - **Windows**: Распакуйте архив `windows-exe` и запустите `csv_json_generator.exe`
          - **Linux**: Установите `.rpm` пакет через `sudo dnf install *.rpm`
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

