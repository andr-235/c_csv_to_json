name: Build Application

on:
  push:
    branches: [ main, master ]
    tags:
      - 'v*'
  pull_request:
    branches: [ main, master ]
  release:
    types: [ created ]
  workflow_dispatch:

jobs:
  build-windows:
    name: Build Windows .exe
    runs-on: windows-latest
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install flet
    
    - name: Build Windows executable
      run: |
        Write-Host "=== Starting Flet build ==="
        Write-Host "Python version:"
        python --version
        Write-Host "Flet version:"
        flet --version
        Write-Host "Current directory:"
        Get-Location
        Write-Host "Directory contents:"
        Get-ChildItem | Select-Object Name, Length
        Write-Host "`n=== Environment variables ==="
        Write-Host "PYTHONIOENCODING: $env:PYTHONIOENCODING"
        Write-Host "FLET_LOG_LEVEL: $env:FLET_LOG_LEVEL"
        Write-Host "`n=== Running flet build windows with verbose logging ==="
        
        # Set verbose environment variables
        $env:FLET_LOG_LEVEL = "DEBUG"
        $env:VERBOSE = "1"
        $env:FLUTTER_VERBOSE = "1"
        
        # Run build and capture both stdout and stderr
        $buildOutput = flet build windows 2>&1 | Tee-Object -FilePath build_log.txt
        
        # Also try to capture Flutter build logs
        if (Test-Path "build\flutter\windows\build\runner\Release\build.log") {
          Write-Host "`n=== Flutter build log ==="
          Get-Content "build\flutter\windows\build\runner\Release\build.log" -Tail 100 -ErrorAction SilentlyContinue
        }
        
        # Check for CMake logs
        $cmakeLogs = Get-ChildItem -Path build -Recurse -Filter "CMake*.log" -ErrorAction SilentlyContinue | Select-Object -First 5
        if ($cmakeLogs) {
          Write-Host "`n=== CMake logs found ==="
          foreach ($log in $cmakeLogs) {
            Write-Host "`n--- $($log.FullName) ---"
            Get-Content $log.FullName -Tail 50 -ErrorAction SilentlyContinue
          }
        }
        
        Write-Host "`n=== Build completed ==="
        Write-Host "Exit code: $LASTEXITCODE"
        if (Test-Path build_log.txt) {
          Write-Host "Build log saved to build_log.txt ($((Get-Item build_log.txt).Length) bytes)"
          Write-Host "`n=== Last 100 lines of build log ==="
          Get-Content build_log.txt -Tail 100
        }
        
        # Check for errors in log
        if (Test-Path build_log.txt) {
          $errors = Select-String -Path build_log.txt -Pattern "error|Error|ERROR|failed|Failed|FAILED|exception|Exception" -CaseSensitive:$false
          if ($errors) {
            Write-Host "`n=== Potential errors/warnings in log ==="
            $errors | Select-Object -First 20 | ForEach-Object { Write-Host $_.Line }
          }
        }
      env:
        PYTHONIOENCODING: utf-8
        FLET_LOG_LEVEL: DEBUG
        VERBOSE: 1
        FLUTTER_VERBOSE: 1
    
    - name: Collect all build logs
      shell: pwsh
      if: always()
      run: |
        Write-Host "=== Collecting all build logs ==="
        $logsDir = "build_logs"
        New-Item -ItemType Directory -Force -Path $logsDir | Out-Null
        
        # Copy main build log
        if (Test-Path build_log.txt) {
          Copy-Item build_log.txt -Destination "$logsDir\flet_build.log" -Force
          Write-Host "Copied: flet_build.log"
        }
        
        # Find and copy all log files
        $allLogs = Get-ChildItem -Path build -Recurse -Include "*.log","*.txt" -ErrorAction SilentlyContinue | Where-Object {
          $_.Name -like "*log*" -or $_.Name -like "*error*" -or $_.Name -like "*build*"
        }
        
        if ($allLogs) {
          Write-Host "Found $($allLogs.Count) log file(s):"
          foreach ($log in $allLogs) {
            $relativePath = $log.FullName.Replace((Get-Location).Path + "\", "").Replace("\", "_")
            $destPath = Join-Path $logsDir $relativePath
            $destDir = Split-Path $destPath -Parent
            if (-not (Test-Path $destDir)) {
              New-Item -ItemType Directory -Force -Path $destDir | Out-Null
            }
            Copy-Item $log.FullName -Destination $destPath -Force -ErrorAction SilentlyContinue
            Write-Host "  Copied: $relativePath"
          }
        }
        
        # Copy CMake cache and config
        $cmakeFiles = Get-ChildItem -Path build -Recurse -Include "CMakeCache.txt","CMakeFiles" -ErrorAction SilentlyContinue
        if ($cmakeFiles) {
          Write-Host "Found CMake files:"
          foreach ($file in $cmakeFiles) {
            if ($file.PSIsContainer) {
              $relativePath = $file.FullName.Replace((Get-Location).Path + "\", "").Replace("\", "_")
              Copy-Item $file.FullName -Destination "$logsDir\$relativePath" -Recurse -Force -ErrorAction SilentlyContinue
            } else {
              $relativePath = $file.FullName.Replace((Get-Location).Path + "\", "").Replace("\", "_")
              Copy-Item $file.FullName -Destination "$logsDir\$relativePath" -Force -ErrorAction SilentlyContinue
            }
            Write-Host "  Copied: $relativePath"
          }
        }
        
        Write-Host "`n=== Logs summary ==="
        Get-ChildItem -Path $logsDir -Recurse -File | ForEach-Object {
          Write-Host "$($_.Name): $([math]::Round($_.Length/1KB, 2)) KB"
        }
    
    - name: Upload build logs
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: build-logs
        path: |
          build_log.txt
          build_logs/**
          build/**/*.log
          build/**/CMakeCache.txt
        retention-days: 7
    
    - name: Find executable and prepare package
      shell: pwsh
      run: |
        Write-Host "=== Searching for .exe files ==="
        Write-Host "Build directory structure:"
        if (Test-Path build) {
          Get-ChildItem -Path build -Recurse -Directory | Select-Object -First 20 FullName | ForEach-Object { Write-Host "  $($_.FullName)" }
        } else {
          Write-Host "ERROR: Build directory does not exist!"
          exit 1
        }
        $allExes = Get-ChildItem -Path build -Recurse -Filter "*.exe" -ErrorAction SilentlyContinue
        if ($allExes) {
          Write-Host "Found $($allExes.Count) executable(s):"
          $allExes | ForEach-Object { 
            Write-Host "  $($_.FullName) (Size: $([math]::Round($_.Length/1MB, 2)) MB)"
          }
          
          $releaseExe = $allExes | Where-Object { $_.DirectoryName -like "*Release*" } | Select-Object -First 1
          if (-not $releaseExe) {
            $releaseExe = $allExes | Where-Object { $_.DirectoryName -like "*runner*" } | Select-Object -First 1
          }
          if (-not $releaseExe) {
            $releaseExe = $allExes | Select-Object -First 1
          }
          
          if ($releaseExe) {
            Write-Host "`nUsing executable: $($releaseExe.FullName)"
            $exeDir = $releaseExe.DirectoryName
            $packageDir = "package"
            New-Item -ItemType Directory -Force -Path $packageDir | Out-Null
            
            Write-Host "Copying executable..."
            Copy-Item $releaseExe.FullName -Destination "$packageDir\$($releaseExe.Name)" -Force
            
            Write-Host "Copying all DLL files from $exeDir..."
            $dlls = Get-ChildItem -Path $exeDir -Filter "*.dll" -ErrorAction SilentlyContinue
            if ($dlls) {
              Write-Host "Found $($dlls.Count) DLL file(s):"
              $dlls | ForEach-Object {
                Copy-Item $_.FullName -Destination "$packageDir\$($_.Name)" -Force
                Write-Host "  Copied: $($_.Name)"
              }
            } else {
              Write-Host "WARNING: No DLL files found in $exeDir"
            }
            
            Write-Host "Searching for DLL files in parent directories..."
            $parentDir = Split-Path $exeDir -Parent
            $allDlls = Get-ChildItem -Path $parentDir -Recurse -Filter "*.dll" -ErrorAction SilentlyContinue | Where-Object { $_.DirectoryName -ne $exeDir }
            if ($allDlls) {
              Write-Host "Found $($allDlls.Count) additional DLL file(s):"
              $allDlls | ForEach-Object {
                $destPath = "$packageDir\$($_.Name)"
                if (-not (Test-Path $destPath)) {
                  Copy-Item $_.FullName -Destination $destPath -Force
                  Write-Host "  Copied: $($_.Name) from $($_.DirectoryName)"
                }
              }
            }
            
            Write-Host "Copying data directory if exists..."
            $dataDir = Join-Path $exeDir "data"
            if (Test-Path $dataDir) {
              Copy-Item -Path $dataDir -Destination "$packageDir\data" -Recurse -Force
              Write-Host "  Copied data directory"
            }
            
            Write-Host "`nPackage prepared in: $packageDir"
            Get-ChildItem -Path $packageDir | ForEach-Object { Write-Host "  $($_.Name) ($([math]::Round($_.Length/1KB, 2)) KB)" }
            
            Write-Host "`n=== Verifying executable ==="
            $exePath = Join-Path $packageDir $releaseExe.Name
            if (Test-Path $exePath) {
              Write-Host "Executable found: $exePath"
              $fileInfo = Get-Item $exePath
              Write-Host "Size: $([math]::Round($fileInfo.Length/1MB, 2)) MB"
              Write-Host "Last modified: $($fileInfo.LastWriteTime)"
              
              # Try to get file version info
              try {
                $versionInfo = [System.Diagnostics.FileVersionInfo]::GetVersionInfo($exePath)
                Write-Host "File version: $($versionInfo.FileVersion)"
                Write-Host "Product version: $($versionInfo.ProductVersion)"
              } catch {
                Write-Host "Could not read version info: $_"
              }
            } else {
              Write-Host "ERROR: Executable not found at $exePath"
              exit 1
            }
          } else {
            Write-Host "ERROR: Could not find executable"
            Write-Host "All found executables:"
            $allExes | ForEach-Object { Write-Host "  $($_.FullName)" }
            exit 1
          }
        } else {
          Write-Host "ERROR: No .exe files found in build directory"
          Write-Host "`nBuild directory structure:"
          if (Test-Path build) {
            Get-ChildItem -Path build -Recurse -Directory | Select-Object -First 30 | ForEach-Object { Write-Host "  $($_.FullName)" }
            Write-Host "`nAll files in build directory:"
            Get-ChildItem -Path build -Recurse -File | Select-Object -First 50 FullName | ForEach-Object { Write-Host "  $($_.FullName)" }
          } else {
            Write-Host "Build directory does not exist!"
          }
            exit 1
        }
    
    - name: Test executable (basic check)
      shell: pwsh
      run: |
        $exePath = Get-ChildItem -Path package -Filter "*.exe" -ErrorAction SilentlyContinue | Select-Object -First 1
        if ($exePath) {
          Write-Host "=== Testing executable: $($exePath.FullName) ==="
          Write-Host "File exists: $(Test-Path $exePath.FullName)"
          Write-Host "File size: $([math]::Round($exePath.Length/1MB, 2)) MB"
          
          # Check if it's a valid PE executable
          $bytes = [System.IO.File]::ReadAllBytes($exePath.FullName)
          if ($bytes.Length -ge 2) {
            $peSignature = [System.Text.Encoding]::ASCII.GetString($bytes[0..1])
            if ($peSignature -eq "MZ") {
              Write-Host "✓ Valid PE executable (MZ signature found)"
            } else {
              Write-Host "⚠ Warning: File does not have MZ signature"
            }
          }
          
          Write-Host "Executable verification complete"
        } else {
          Write-Host "ERROR: No executable found in package directory"
          exit 1
        }
      continue-on-error: true
    
    - name: Upload Windows artifact
      uses: actions/upload-artifact@v4
      with:
        name: windows-exe
        path: |
          package/*.exe
          package/*.dll
          package/data/**
        if-no-files-found: error
        retention-days: 30

  build-linux-rpm:
    name: Build Linux .rpm (Fedora)
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Build RPM in Fedora container
      run: |
        echo "=== Starting Linux RPM build ==="
        echo "Workspace: ${{ github.workspace }}"
        docker run --rm \
          -v ${{ github.workspace }}:/workspace \
          -w /workspace \
          fedora:latest bash -c "
          set -e
          set -x
          echo '=== Installing dependencies ==='
          dnf install -y rpm-build python3-devel python3-pip git 2>&1 | tee /tmp/dnf_install.log
          echo '=== Python version ==='
          python3 --version
          echo '=== Installing Python packages ==='
          python3 -m pip install --upgrade pip 2>&1 | tee /tmp/pip_upgrade.log
          pip3 install briefcase flet 2>&1 | tee /tmp/pip_install.log
          echo '=== Briefcase version ==='
          briefcase --version || echo 'Briefcase not found'
          echo '=== Flet version ==='
          flet --version || echo 'Flet not found'
          echo '=== Current directory structure ==='
          ls -la /workspace/ || true
          echo '=== Creating briefcase project ==='
          briefcase create 2>&1 | tee /tmp/briefcase_create.log || echo 'Briefcase create failed, continuing...'
          echo '=== Building project ==='
          briefcase build 2>&1 | tee /tmp/briefcase_build.log || briefcase build linux 2>&1 | tee /tmp/briefcase_build.log || echo 'Build failed, continuing...'
          echo '=== Packaging RPM ==='
          briefcase package --format rpm 2>&1 | tee /tmp/briefcase_package.log || briefcase package linux --format rpm 2>&1 | tee /tmp/briefcase_package.log || echo 'Package failed'
          echo '=== Build logs ==='
          echo '--- DNF Install Log ---'
          cat /tmp/dnf_install.log || true
          echo '--- Briefcase Create Log ---'
          cat /tmp/briefcase_create.log || true
          echo '--- Briefcase Build Log ---'
          cat /tmp/briefcase_build.log || true
          echo '--- Briefcase Package Log ---'
          cat /tmp/briefcase_package.log || true
          echo '=== Checking for RPM files in /workspace ==='
          find /workspace -name '*.rpm' -type f 2>/dev/null | head -20
          echo '=== Checking dist directory ==='
          if [ -d /workspace/dist ]; then
            echo 'dist directory exists:'
            ls -lah /workspace/dist/ || true
            RPM_COUNT=\$(find /workspace/dist -name '*.rpm' -type f 2>/dev/null | wc -l)
            echo \"Found \$RPM_COUNT RPM file(s) in dist/\"
          else
            echo 'WARNING: dist directory does not exist in /workspace'
            echo 'Checking all directories:'
            find /workspace -type d -maxdepth 2 | head -20
          fi
          echo '=== Final workspace structure ==='
          ls -la /workspace/ | head -30
          "
    
    - name: Check RPM build result
      run: |
        echo "=== Checking RPM build results ==="
        echo "Current directory: $(pwd)"
        echo "Workspace contents:"
        ls -la | head -20
        echo ""
        echo "Searching for RPM files in workspace:"
        find . -name "*.rpm" -type f 2>/dev/null | head -20 || echo "No RPM files found"
        echo ""
        if [ -d dist ]; then
          echo "✓ dist directory exists"
          ls -lah dist/
          RPM_COUNT=$(find dist -name "*.rpm" -type f 2>/dev/null | wc -l)
          echo "Found $RPM_COUNT RPM file(s)"
          if [ $RPM_COUNT -eq 0 ]; then
            echo "WARNING: No RPM files found in dist/"
            echo "Contents of dist/:"
            ls -la dist/ || true
            echo "Searching in other locations:"
            find . -type d -name "*dist*" 2>/dev/null | head -10
          else
            echo "✓ RPM files found:"
            find dist -name "*.rpm" -type f -exec ls -lh {} \;
          fi
        else
          echo "WARNING: dist directory does not exist"
          echo "Checking for alternative locations:"
          find . -type d -name "*dist*" -o -name "*build*" 2>/dev/null | head -20
          echo ""
          echo "All directories in workspace:"
          find . -type d -maxdepth 2 2>/dev/null | head -30
          echo ""
          echo "NOTE: This is not a fatal error - RPM build may have failed or used different output location"
        fi
    
    - name: Upload Linux RPM artifact
      uses: actions/upload-artifact@v4
      with:
        name: linux-rpm
        path: dist/*.rpm
        if-no-files-found: warn
        retention-days: 30

  create-release:
    name: Create Release
    needs: [build-windows, build-linux-rpm]
    runs-on: ubuntu-latest
    if: |
      (github.event_name == 'release' && github.event.action == 'created') ||
      (github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v'))
    
    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0
    
    - name: Get version from tag
      id: get_version
      run: |
        if [ "${{ github.event_name }}" == "push" ]; then
          VERSION=${GITHUB_REF#refs/tags/}
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "tag=$VERSION" >> $GITHUB_OUTPUT
        else
          VERSION=${{ github.event.release.tag_name }}
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "tag=$VERSION" >> $GITHUB_OUTPUT
        fi
        echo "Version: $VERSION"
    
    - name: Download Windows artifacts
      uses: actions/download-artifact@v4
      with:
        name: windows-exe
        path: release/windows
    
    - name: Download Linux RPM artifacts
      uses: actions/download-artifact@v4
      continue-on-error: true
      with:
        name: linux-rpm
        path: release/linux
    
    - name: Create Release
      uses: softprops/action-gh-release@v1
      with:
        tag_name: ${{ steps.get_version.outputs.tag }}
        name: Release ${{ steps.get_version.outputs.version }}
        files: |
          release/windows/**
          release/linux/**
        draft: false
        prerelease: false
        generate_release_notes: true
        body: |
          ## Что нового
          
          Автоматически собранные артефакты для версии ${{ steps.get_version.outputs.version }}
          
          ### Скачать
          - **Windows**: Распакуйте архив `windows-exe` и запустите `csv_json_generator.exe`
          - **Linux**: Установите `.rpm` пакет через `sudo dnf install *.rpm`
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

